<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Taming the XML beast!</title><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=stylesheet href=/css/7fa1.blog.css><!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]--><link rel=apple-touch-icon-precomposed sizes=144x144 href=/images/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link rel=alternate type=application/atom+xml title="Toon Verwerft" href=https://veewee.github.io/atom.xml><meta property=og:description content="Imagine a world ... in which you didn't have to deal with all PHP's strange XML quirks. The people following me on Twitter might have noticed that I don't like the XML tools that PHP currently provides. My main frustrations with the built-in tools can be divided in 2 big items: The lack of error handling and the bloated APIs."><meta property=og:title content="Taming the XML beast!"><meta property=og:image content=https://veewee.github.io/images/blog/20210207/xml-beast_thumb.png><meta property=og:image:width content=500><meta property=og:image:height content=375><meta name=twitter:card content=summary_large_image><meta name=twitter:site content=@toonverwerft><meta name=twitter:creator content=@toonverwerft></head><body class=bs-docs-home><a class=sr-only href=#content>Skip to main content</a><header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role=banner><div class=container><div class=navbar-header><button class=navbar-toggle type=button data-toggle=collapse data-target=.bs-navbar-collapse><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a href="/" class=navbar-brand>Toon Verwerft</a></div><nav class="collapse navbar-collapse bs-navbar-collapse" role=navigation><ul class="nav navbar-nav"><li><a href="/">Home</a></li><li><a href=https://twitter.com/toonverwerft>Twitter</a></li><li><a href="https://github.com/veewee/">Github</a></li><li><a href=https://www.linkedin.com/in/toonverwerft>LinkedIn</a></li><li><a href=https://speakerdeck.com/veewee>Talks</a></li></ul></nav></div></header><a name=#content></a><div id=content><div class=container><div class=row><div class="col-xs-12 col-sm-8 col-md-9 left-pane"><div class=post-details><h1>Taming the XML beast!</h1><div class=pull-right><span class="meta label label-info">07 Feb 2021</span></div><small>Tags: <span class="label label-primary tag">XML</span> <span class="label label-primary tag">PHP</span></small><div class=post><img src=/images/blog/20210207/xml-beast-long.png class=post-banner alt=""><p>Imagine a world ... in which you didn't have to deal with all PHP's strange XML quirks. The people following me on <a href=https://twitter.com/toonverwerft target=_blank>Twitter</a> might have noticed that I don't like the XML tools that PHP currently provides. My main frustrations with the built-in tools can be divided in 2 big items: The lack of error handling and the bloated APIs.</p><h2>Lack of error handling</h2><p>Most of the time, you&#39;ll be working with XML files of which you know they contain valid XML syntax. In some situations however, you might receive invalid XML or XML that is not valid according to an XSD schema. At this point, lib-xml gives you following:</p><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=nv>$doc</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>DOMDocument</span><span class=p>();</span>
<span class=nv>$result</span> <span class=o>=</span> <span class=nv>$doc</span><span class=o>-&gt;</span><span class=na>loadXML</span><span class=p>(</span><span class=s1>&#39;&lt;invalid&gt;&#39;</span><span class=p>);</span>

<span class=nb>var_dump</span><span class=p>(</span><span class=nv>$result</span><span class=p>);</span></code></pre></figure><p>Resulting in:</p><div class=highlight><pre><code class=language-text data-lang=text><span></span>Warning: DOMDocument::loadXML():
  Premature end of data in tag invalid line 1 in Entity,
  line: 1 in /in/0I8Or on line 4

bool(false)
</code></pre></div><p>Yes, that is right... It returns false and it triggers ... a PHP warning ... This means that code execution is not being stopped and a shitload of other warnings will be triggered if you do not check the false case of the loadXML function.</p><p>If you want to cover up the warning and display the actual XML issue, you&#39;ll have to write code that looks like this.</p><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=nv>$doc</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>DOMDocument</span><span class=p>();</span>

<span class=nv>$previousErrorReporting</span> <span class=o>=</span> <span class=nb>libxml_use_internal_errors</span><span class=p>(</span><span class=k>true</span><span class=p>);</span>
<span class=nb>libxml_clear_errors</span><span class=p>();</span>

<span class=nv>$result</span> <span class=o>=</span> <span class=nv>$doc</span><span class=o>-&gt;</span><span class=na>loadXML</span><span class=p>(</span><span class=s1>&#39;&lt;invalid&gt;&#39;</span><span class=p>);</span>

<span class=nv>$errors</span> <span class=o>=</span> <span class=nb>libxml_get_errors</span><span class=p>();</span>
<span class=nb>libxml_clear_errors</span><span class=p>();</span>
<span class=nb>libxml_use_internal_errors</span><span class=p>(</span><span class=nv>$previousErrorReporting</span><span class=p>);</span>

<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nv>$result</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Do something with the errors and break execution</span>
<span class=p>}</span></code></pre></figure><p>Do note that most XML functions work in a similar way: they return false and trigger a warning. So if you want to reliably work with XML, you need to wrap them all with your own error handling.</p><p>The code above can be found in so many packages out there. It&#39;s like everybody is OK with this approach. At least, I am not!</p><h2>Bloated API</h2><p>The XML extensions provided by PHP contain functions for everything you want to do with XML. The DOMDocument class contains about 50 functions and 20 properties (estimated values) which all have their own purpose. This is only the main entry point of your XML, besides that you can find DOMElements, DOMNodes, DOMAttributes, ... which all have a similar amount of functions.</p><p>Don&#39;t get me wrong, I like this structure: It is created to do whatever you want to do with XML. You want to load XML, fine! Or do you rather manipulate something, fine as well! Do whatever you please! The downside of this all, is that you need to know a lot about the low level API!</p><p>To give you an example for day-to-day loading of XML:</p><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=nv>$document</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>DOMDocument</span><span class=p>();</span>
<span class=nv>$document</span><span class=o>-&gt;</span><span class=na>encoding</span> <span class=o>=</span> <span class=s1>&#39;UTF-8&#39;</span><span class=p>;</span>
<span class=nv>$document</span><span class=o>-&gt;</span><span class=na>preserveWhiteSpace</span> <span class=o>=</span> <span class=k>false</span><span class=p>;</span>
<span class=nv>$document</span><span class=o>-&gt;</span><span class=na>formatOutput</span> <span class=o>=</span> <span class=k>true</span><span class=p>;</span>

<span class=c1>// wrap error handling here ...</span>
<span class=nv>$result</span> <span class=o>=</span> <span class=nv>$document</span><span class=o>-&gt;</span><span class=na>loadXML</span><span class=p>(</span><span class=s1>&#39;&lt;root /&gt;&#39;</span><span class=p>);</span>

<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nv>$result</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Custom error handling</span>
<span class=p>}</span></code></pre></figure><p>With error handling, this is about 15 lines of code for just loading an XML file! Not to mention that I needed to look up every property in there ...</p><p>The same goes for basically any manipulation you want to do. Did you ever try to create an XML document with DOMDocument? It&#39;s aweful - because it is all this ultra flexible.</p><p>What if we were able to split all these functions and different XML types per use case? That way we could create a smaller Document class that you can use to perform specific types of actions:</p><ul><li>Loading with configurable settings.</li><li>Validating based on whatever schema you please.</li><li>Building XML</li><li>Manipulating XML</li><li>Locating items inside an XML</li><li>...</li></ul><h2>Other components</h2><p>I don&#39;t want to convert this blog post into a big rant, so I am not going to focus on all other XML components at this moment. So instead of complaining, let&#39;s deal with these problems and let&#39;s create something that covers these problems instead.</p><h1>XML without worries</h1><p>In order to tame the XML beast, I decided to create yet another package. It&#39;s not that there isn&#39;t any XML library out there, but most focus on 1 specific problem or are bloated wrappers around DOMDocument. With this package I want to improve ALL XML extensions that are available in PHP.</p><p>The goal of the package is to provide all tools for dealing with XML in PHP without worries. You will find a type-safe, declarative API that deals with errors for you!</p><p>Currently the package provides DOM, XSD, XSLT, Error-Handling and Reader components. In the future I will also focus on additional components like a memory-safe Writer and focus a bit on &quot;simple&quot;Xml. There is a lot of stuff to discover, so let me give you a couple of highlights which I personally really like!</p><h2>Locating data inside an XML document</h2><h3>Loading the XML document</h3><p>You can load an XML document with configurable functions to determine how it will load. These configurable functions can contain whatever you want:</p><ul><li>Specify encoding</li><li>Specify output</li><li>Validate internal XSD schema&#39;s whilst loading</li><li>You can create custom configurators that e.g. replace import statements with their eventual XML (flattening)</li><li>...</li></ul><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=k>use</span> <span class=nx>VeeWee\XML\DOM\Configurator</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\XML\DOM\Document</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\XML\DOM\Loader</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\XML\DOM\Validator</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\Xml\ErrorHandling\Issue\Level</span><span class=p>;</span>

<span class=nv>$doc</span> <span class=o>=</span> <span class=nx>Document</span><span class=o>::</span><span class=na>configure</span><span class=p>(</span>
    <span class=nx>Configurator\utf8</span><span class=p>(),</span>
    <span class=nx>Configurator\trim_spaces</span><span class=p>(),</span>
    <span class=nx>Configurator\Loader</span><span class=p>(</span>
      <span class=nx>Loader\xml_file_loader</span><span class=p>(</span><span class=s1>&#39;data.xml&#39;</span><span class=p>)</span>
    <span class=p>),</span>
    <span class=nx>Configurator\validator</span><span class=p>(</span>
        <span class=nx>Validator\internal_xsd_validator</span><span class=p>(),</span>
        <span class=nx>Level</span><span class=o>::</span><span class=na>warning</span><span class=p>()</span>
    <span class=p>)</span>
<span class=p>);</span></code></pre></figure><h3>XPath improvements</h3><p>Next up is the actual querying. You start of by configuring how you want to create your XPath object. In this case, you can configure it with lookup namespaces:</p><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=k>use</span> <span class=nx>Psl\Type</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\XML\DOM\Xpath\Configurator</span><span class=p>;</span>

<span class=nv>$xpath</span> <span class=o>=</span> <span class=nv>$doc</span><span class=o>-&gt;</span><span class=na>xpath</span><span class=p>(</span>
    <span class=nx>Configurator\namespaces</span><span class=p>([</span>
        <span class=s1>&#39;acme&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;http://acme.com&#39;</span><span class=p>,</span>
    <span class=p>])</span>
<span class=p>);</span>

<span class=nv>$currentNode</span> <span class=o>=</span> <span class=nv>$xpath</span><span class=o>-&gt;</span><span class=na>querySingle</span><span class=p>(</span><span class=s1>&#39;//acme:products&#39;</span><span class=p>);</span>
<span class=nv>$count</span> <span class=o>=</span> <span class=nv>$xpath</span><span class=o>-&gt;</span><span class=na>evaluate</span><span class=p>(</span><span class=s1>&#39;count(.//item)&#39;</span><span class=p>,</span> <span class=nx>Type\int</span><span class=p>(),</span> <span class=nv>$currentNode</span><span class=p>);</span></code></pre></figure><p>After creating the XPath object, you can see a new function <code>querySingle</code>. I found myself frequently looking for one element and wanted to make that possible. Another addition is typed evaluation. By specifying a type, you can make sure that the $count variable actually contains an integer or throws an exception instead.</p><p>If you write an error in your XPath query, you will receive a meaningfull error message explaining you what is wrong with your query!</p><h3>Memory-safe Reading</h3><p>If you have a very big XML file, you want to lookup nodes in a memory-safe way. The improved version of the XMLReader looks like this:</p><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=k>use</span> <span class=nx>VeeWee\Xml\Dom\Document</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\Xml\Reader\Configurator</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\Xml\Reader\Reader</span><span class=p>;</span>
<span class=k>use</span> <span class=nx>VeeWee\Xml\Reader\Matcher</span><span class=p>;</span>

<span class=nv>$reader</span> <span class=o>=</span> <span class=nx>Reader</span><span class=o>::</span><span class=na>fromXmlFile</span><span class=p>(</span>
    <span class=s1>&#39;large-data.xml&#39;</span><span class=p>,</span>
    <span class=nx>Configurator\xsd_schema</span><span class=p>(</span><span class=s1>&#39;schema.xsd&#39;</span><span class=p>)</span>
<span class=p>);</span>

<span class=sd>/** @var \Generator&lt;string&gt; $provider */</span>
<span class=nv>$provider</span> <span class=o>=</span> <span class=nv>$reader</span><span class=o>-&gt;</span><span class=na>provide</span><span class=p>(</span>
    <span class=nx>Matcher\all</span><span class=p>(</span>
        <span class=nx>Matcher\node_name</span><span class=p>(</span><span class=s1>&#39;item&#39;</span><span class=p>),</span>
        <span class=nx>Matcher\node_attribute</span><span class=p>(</span><span class=s1>&#39;locale&#39;</span><span class=p>,</span> <span class=s1>&#39;nl-BE&#39;</span><span class=p>)</span>
    <span class=p>)</span>
<span class=p>);</span>

<span class=k>foreach</span> <span class=p>(</span><span class=nv>$provider</span> <span class=k>as</span> <span class=nv>$nlItem</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>$dom</span> <span class=o>=</span> <span class=nx>Document</span><span class=o>::</span><span class=na>fromXmlString</span><span class=p>(</span><span class=nv>$nlItem</span><span class=p>);</span>
    <span class=c1>// Do something with it</span>
<span class=p>}</span></code></pre></figure><p>You can trust this reader to handle the boring node traversal for you. By specifying matcher functions, you are in control of what XML strings are yielded. From that point on, you can e.g. use a regular Document to deal with the smaller XML chunks.</p><p>The reader is able to detect errors or invalid schema implementations whilst iterating over the dataset lazily. You will receive a meaningful exception at all time!</p><h2>Writing</h2><p>Reading is a bug chunk of your day-to-day XML usage, but in some cases you mind want to create or manipulate an XML. In the XML package, you will find some tools that make building XML quite intuitive. You basically specify what the XML should look like:</p><figure class=highlight><pre><code class=language-php data-lang=php><span></span><span class=cp>&lt;?php</span>

<span class=k>use</span> <span class=nx>VeeWee\Xml\Dom\Document</span><span class=p>;</span>
<span class=k>use</span> <span class=k>function</span> <span class=nf>VeeWee\Xml\Dom\Builder\attribute</span><span class=p>;</span>
<span class=k>use</span> <span class=k>function</span> <span class=nf>VeeWee\Xml\Dom\Builder\children</span><span class=p>;</span>
<span class=k>use</span> <span class=k>function</span> <span class=nf>VeeWee\Xml\Dom\Builder\element</span><span class=p>;</span>
<span class=k>use</span> <span class=k>function</span> <span class=nf>VeeWee\Xml\Dom\Builder\namespaced_element</span><span class=p>;</span>
<span class=k>use</span> <span class=k>function</span> <span class=nf>VeeWee\Xml\Dom\Builder\value</span><span class=p>;</span>
<span class=k>use</span> <span class=k>function</span> <span class=nf>VeeWee\Xml\Dom\Manipulator\append</span><span class=p>;</span>

<span class=nv>$doc</span> <span class=o>=</span> <span class=nx>Document</span><span class=o>::</span><span class=na>empty</span><span class=p>();</span>
<span class=nv>$doc</span><span class=o>-&gt;</span><span class=na>manipulate</span><span class=p>(</span>
    <span class=nx>append</span><span class=p>(</span><span class=o>...</span><span class=nv>$doc</span><span class=o>-&gt;</span><span class=na>build</span><span class=p>(</span>
        <span class=nx>element</span><span class=p>(</span><span class=s1>&#39;root&#39;</span><span class=p>,</span> <span class=nx>children</span><span class=p>(</span>
            <span class=nx>element</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span>
                <span class=nx>attribute</span><span class=p>(</span><span class=s1>&#39;bar&#39;</span><span class=p>,</span> <span class=s1>&#39;baz&#39;</span><span class=p>),</span>
                <span class=nx>value</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>)</span>
            <span class=p>),</span>
            <span class=nx>namespaced_element</span><span class=p>(</span><span class=s1>&#39;http://namespace&#39;</span><span class=p>,</span> <span class=s1>&#39;foo&#39;</span><span class=p>,</span>
                <span class=nx>attribute</span><span class=p>(</span><span class=s1>&#39;bar&#39;</span><span class=p>,</span> <span class=s1>&#39;baz&#39;</span><span class=p>),</span>
                <span class=nx>children</span><span class=p>(</span>
                    <span class=nx>element</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=nx>value</span><span class=p>(</span><span class=s1>&#39;world&#39;</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>
        <span class=p>))</span>
    <span class=p>))</span>
<span class=p>);</span>

<span class=nv>$xml</span> <span class=o>=</span> <span class=nv>$doc</span><span class=o>-&gt;</span><span class=na>toXmlString</span><span class=p>();</span></code></pre></figure><h1>In closing</h1><p>The snippets above are only some highlights of the package. There is a lot more in there for you to discover!</p><p>At this moment, the package already contains a lot of components that you can use on a day-to-day basis. Since XML is very broad, there are still missing functions. It might contain some rough corners and will surely grow in time.</p><p>It has to start somewhere, it has to start sometime What better place than here, what better time than now?!</p><h3>Introducing <a href=https://github.com/veewee/xml target=_blank>veewee/xml</a>!</h3><p>Feel free to drop me any feedback.</p><p>Hope you love it!</p></div><a name=comments></a><div id=disqus_thread></div><script type=text/javascript>var disqus_identifier = '/blog/taming-the-xml-beast/';
        var disqus_title = 'Taming the XML beast!';
        var disqus_url = 'http://veewee.github.io/blog/taming-the-xml-beast/';

        // trigger disqus-comments.js
        var embed_disqus_comments = true;</script></div></div><div class="col-xs-12 col-sm-4 col-md-3 right-pane"><h1>whois <small>VeeWee</small></h1><div><img src=/images/picture.png class="img-thumbnail img-responsive selfie" alt=Selfie></div><div><h2>Hi there!</h2><p>Glad you made it to my blog. Please feel free to take a look around. You will find some interesting stuff, mostly about web development and PHP.</p><p>Still can't get enough of me? Quick! Take a look at my <a href=https://speakerdeck.com/veewee>Speakerdeck</a>, <a href=https://twitter.com/toonverwerft>Twitter</a> or <a href="https://github.com/veewee/">Github</a> account.</p></div><div class=list-group><a class=list-group-item href=//github.com/veewee/veewee.github.io/issues/new><span class="glyphicon glyphicon-pencil"></span> Contact Me</a> <a class=list-group-item href=/atom.xml><span class="glyphicon glyphicon-pushpin"></span> Subscribe to RSS</a></div></div></div></div></div><script src=/js/b1a7.vendor.js></script><script src=/js/e51f.blog.js></script></body></html>