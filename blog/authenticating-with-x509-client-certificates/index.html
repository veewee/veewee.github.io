<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Authenticating with X.509 client certificates</title><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=stylesheet href=/css/a862.blog.css><!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]--><link rel=apple-touch-icon-precomposed sizes=144x144 href=/images/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link rel=alternate type=application/atom+xml title="Toon Verwerft" href=https://veewee.github.io/atom.xml></head><body class=bs-docs-home><a class=sr-only href=#content>Skip to main content</a><header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role=banner><div class=container><div class=navbar-header><button class=navbar-toggle type=button data-toggle=collapse data-target=.bs-navbar-collapse><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a href="/" class=navbar-brand>Toon Verwerft</a></div><nav class="collapse navbar-collapse bs-navbar-collapse" role=navigation><ul class="nav navbar-nav"><li><a href="/">Home</a></li><li><a href=//twitter.com/toonverwerft>Twitter</a></li><li><a href="//github.com/veewee/">Github</a></li><li><a href=//www.linkedin.com/pub/toon-verwerft/36/b90/a2b>LinkedIn</a></li></ul></nav></div></header><a name=#content></a><div id=content><div class=container><div class=row><div class="col-xs-12 col-sm-8 col-md-9 left-pane"><div class=post-details><h1>Authenticating with X.509 client certificates</h1><div class=pull-right><span class="meta label label-info">07 Dec 2015</span></div><small>Tags: <a href=/tags/ssl class="label label-primary tag" title="View posts tagged with &quot;ssl&quot;">ssl</a> <a href=/tags/authentication class="label label-primary tag" title="View posts tagged with &quot;authentication&quot;">authentication</a> <a href=/tags/symfony class="label label-primary tag" title="View posts tagged with &quot;symfony&quot;">symfony</a> <a href=/tags/php class="label label-primary tag" title="View posts tagged with &quot;php&quot;">php</a></small><div class=post><img src=/images/blog/20151207/1c9c.security.jpg class=post-banner alt=""><p>Last week, I was diving in different authentication systems for API's. One of the better ways of authentication is through <a href=https://en.wikipedia.org/wiki/X.509 target=_blank>X.509 client certificates</a>. This one is a bit is harder to set-up, but sure is secure, manageable and powerful. While searching for documentation on the subject, I was surprised there weren't a lot of good articles. In this article, I will try to explain every step as easy as possible.</p><h2>Why should I use X.509 authentication?</h2><p>The main advantage is that the client is not sending a username or password to the server. This means that a man-in-the-middle attack is nearly impossible. It is much easier to steal a username/password login, for example by bruteforcing, then stealing a certificate. Because the certificate is signed, it is only possible to connect to the real server. It is possible to revoke and manage these certificates in an easy way.</p><h2>Configuring the server</h2><p>Client Certificate authentication can only be done while running HTTPS. So first of all, make sure the server is running HTTPS. This can be done with a self-signed or a signed certificate. Your apache VHost configuration should look more or less like this:</p><div class=highlight><pre><code class=apache><span class=nb>SSLEngine</span> <span class=k>on</span>
<span class=nb>SSLCertificateFile</span>      <span class=s2>&quot;/etc/ssl/certs/server.pem&quot;</span>
<span class=nb>SSLCertificateKeyFile</span>   <span class=s2>&quot;/etc/ssl/private/server.key&quot;</span>
<span class=nb>SSLProtocol</span>             TLSv1 TLSv1.1 TLSv1.2
<span class=nb>SSLCipherSuite</span>          <span class=s2>&quot;.......&quot;</span>
 
<span class=c># When using signed certificates:</span>
<span class=nb>SSLCertificateChainFile</span> <span class=s2>&quot;/etc/ssl/yourDomainName.ca-bundle&quot;</span>
</code></pre></div><p>Now that you got HTTPS up and running, you should be able to browse to your application through HTTPS.</p><h3>Creating a certification authority</h3><p>A certification authority (CA) hands out a digital certificate in which the CA says that a public key in the certificate, belongs to the person, organization, server or entity that is mentioned in the certificate. In our example, this will be done based on the e-mail address that is provided in the certificate. The task of the CA is to control the identity of the issuer, so that the client that is using the certificates from the CA can be trusted.</p><p>First we will need to create the CA private key and certificate:</p><div class=highlight><pre><code class=bash><span class=nb>cd</span> /etc/ssl/certs/
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 365 -key ca.key -out ca.crt
</code></pre></div><div class="alert alert-warning"><strong>Note:</strong> Make sure to set the CN to a valid server domain. Otherwise this might result in exceptions!</div><p>Now that we have the CA key and certificate, we can register it to Apache to validate the client certificates:</p><div class=highlight><pre><code class=apache><span class=nb>SSLCACertificateFile</span> <span class=s2>&quot;/etc/ssl/certs/ca.crt&quot;</span>
<span class=nb>SSLVerifyClient</span> optional
<span class=nb>SSLVerifyDepth</span> <span class=m>1</span>
<span class=nb>SSLOptions</span> +StdEnvVars
</code></pre></div><p>As you can see the client certificate verification is optional. This will make it possible to add another type of authentication like basic authentication when there is nog client certificate. The verify depth is set to 1 so that it only accepts certificates signed by the configured CA. Finally, the StdEnvVars are registered so that the additional SSL server variables are available in PHP.</p><h2>Configuring the client</h2><p>Now that we got or server fully configured, it is time to create a client certificate. Following commands should be ran on the client machine to create a Certificate Signing Request (CSR):</p><div class=highlight><pre><code class=bash>openssl genrsa -out client.key 4096
openssl req -new -key client.key -out client.csr
</code></pre></div><div class="alert alert-warning"><strong>Note:</strong> Make sure to set the CN to a valid server domain. Otherwise this might result in exceptions!<br><strong>Note:</strong> The email field will be used to authenticate the user.</div><p>The CSR file is useless when it is not signed by the CA. So the logical next step is to transfer the certificate to the server and sign it with the CA.</p><div class=highlight><pre><code class=bash>openssl x509 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt
</code></pre></div><p>The command above results in a useful client certificate. To make it easier to use the certificate, we will pack the client private key and the certificate in one file. This action should run on the client machine:</p><div class=highlight><pre><code class=bash>cat client.crt client.key &gt; client.pem
</code></pre></div><div class="alert alert-warning"><strong>Note:</strong> it's important to place the crt before the key in the pem file!</div><p>In above example the CSR was created on the client, to make it clear that the certificate + key should only be known by the client. However, it is perfectly possible to run all these commands on the server and send the pem file to the client who will be using the certificate. This means that the creation of the client certificate can be automated. You could create your own user interface to make the keys manageable per user of the application. This can for example be done with the built-in <a href=http://php.net/manual/en/book.openssl.php target=_blank>openssl</a> extension of PHP. When the certification file is generated on the server, you should transfer this certificate in a trusted way. For example a download over HTTPS in the back-end of your application.</p><h2>Requesting resources with a client certificate</h2><p>Ok, we configured our server and requested a client certificate. Now how do I use this certificate to get my resources? The easiest way is the add the "<em>-cert</em>" attribute to the curl command. Since we are using Guzzle for HTTP requests, the client configuration will look like this:</p><div class=highlight><pre><code class=php><span class=cp>&lt;?php</span>
<span class=nv>$client</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Guzzle\Http\Client</span><span class=p>(</span><span class=nv>$baseUrl</span><span class=p>,</span> <span class=p>[</span>
    <span class=s1>&#39;ssl.certificate_authority&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;system&#39;</span><span class=p>,</span>
    <span class=s1>&#39;request.options&#39;</span> <span class=o>=&gt;</span> <span class=p>[</span>
        <span class=s1>&#39;cert&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;client.pem&#39;</span><span class=p>,</span>
    <span class=p>]</span>
<span class=p>]);</span>
</code></pre></div><p>As you can see it is possible to specify the certificate in the request.options part of the configuration. Another option is the ssl.certificate_authority. This one can be used to specify which CA that should be used. By default the built-in CA file is being used. You can choose to disable ssl verification or add your own ca file. For example, when using self-signed certificates, you can run following command:</p><div class=highlight><pre><code class=bash>openssl s_client -showcerts -connect my.host.com:443 &gt; ca-file.pem
</code></pre></div><p>This ca-file.pem file will contain the certificate of the certification authority and mark it as trusted. Now it can be used in the PHP configuration as followed:</p><div class=highlight><pre><code class=php><span class=cp>&lt;?php</span>
<span class=nv>$client</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Guzzle\Http\Client</span><span class=p>(</span><span class=nv>$baseUrl</span><span class=p>,</span> <span class=p>[</span>
    <span class=s1>&#39;ssl.certificate_authority&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;ca-file.pem&#39;</span><span class=p>,</span>
    <span class=s1>&#39;request.options&#39;</span> <span class=o>=&gt;</span> <span class=p>[</span>
        <span class=s1>&#39;cert&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;client.pem&#39;</span><span class=p>,</span>
    <span class=p>]</span>
<span class=p>]);</span>
</code></pre></div><h2>X.509 authentication in Symfony</h2><p>One of the less known features of Symfony is X.509 authentication. It can easily be configured with the default x509 authentication security adapter. The configuration is pretty easy:</p><div class=highlight><pre><code class=yaml><span class=l-Scalar-Plain>security</span><span class=p-Indicator>:</span>
    <span class=l-Scalar-Plain>providers</span><span class=p-Indicator>:</span>
        <span class=l-Scalar-Plain>client_certificate</span><span class=p-Indicator>:</span>
            <span class=l-Scalar-Plain>memory</span><span class=p-Indicator>:</span>
                <span class=l-Scalar-Plain>users</span><span class=p-Indicator>:</span>
                    <span class=l-Scalar-Plain>email@certification.file</span><span class=p-Indicator>:</span>
                      <span class=l-Scalar-Plain>roles</span><span class=p-Indicator>:</span> <span class=l-Scalar-Plain>ROLE_SUPER_ADMIN</span>
 
    <span class=l-Scalar-Plain>firewalls</span><span class=p-Indicator>:</span>
        <span class=l-Scalar-Plain>main</span><span class=p-Indicator>:</span>
            <span class=l-Scalar-Plain>x509</span><span class=p-Indicator>:</span>
                <span class=l-Scalar-Plain>provider</span><span class=p-Indicator>:</span> <span class=l-Scalar-Plain>client_certificate</span>
 
    <span class=l-Scalar-Plain>access_control</span><span class=p-Indicator>:</span>
            <span class=p-Indicator>-</span> <span class=p-Indicator>{</span> <span class=nv>path</span><span class=p-Indicator>:</span> <span class=nv>^/</span><span class=p-Indicator>,</span> <span class=nv>roles</span><span class=p-Indicator>:</span> <span class=nv>ROLE_SUPER_ADMIN</span><span class=p-Indicator>,</span> <span class=nv>requires_channel</span><span class=p-Indicator>:</span> <span class=nv>https</span> <span class=p-Indicator>}</span>
</code></pre></div><div class="alert alert-warning"><strong>Note:</strong> This type of authentication only works with HTTPS. <a href=http://symfony.com/doc/current/cookbook/security/force_https.html target=_blank>You might want to enforce HTTPS</a>!</div><p>As you can see HTTPS is enforced and authentication will try X.509 authentication by default. When a valid client certificate is found, Symfony will try to match the email that is configured inside the certificate with a user in the client_certificate user provider. In this case we are using an in-memory provider that links an e-mail to a security role.</p><h2>X.509 authentication in PHP</h2><p>That was easy! But how does it work? By adding the "SSLOptions +StdEnvVars" configuration in Apache, there are some additional "<em>SSL_</em>" environment variables available. These variables contain the email in the client certificate. For example:</p><div class=highlight><pre><code class=php><span class=cp>&lt;?php</span>
<span class=nv>$email</span> <span class=o>=</span> <span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;SSL_CLIENT_S_DN_Email&#39;</span><span class=p>];</span>
<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nv>$email</span> <span class=o>&amp;&amp;</span> <span class=nb>preg_match</span><span class=p>(</span><span class=s1>&#39;#/emailAddress=(.+\@.+\..+)(/|$)#&#39;</span><span class=p>,</span> <span class=nv>$_SERVER</span><span class=p>[</span><span class=s1>&#39;SSL_CLIENT_S_DN&#39;</span><span class=p>],</span> <span class=nv>$matches</span><span class=p>))</span> <span class=p>{</span>
    <span class=nv>$email</span> <span class=o>=</span> <span class=nv>$matches</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>Now that we have the e-mail, it is possible to search this email in the list of configured client_certificates. Symfony will throw an exception when the email can't be found.</p><h2>Conclusion</h2><p>Even though it is a lot of work to get this type of authentication running, it sure is a powerful type of authentication. The users of your application will be able to connect to your application in an improved and secure way. It also comes in very handy for server to server communication in which you don't always want to hardcode user credentials. Your customers will surely thank you for the extra effort you made!</p></div><div class="social clearfix"><div class=addthis_inline_share_toolbox></div><div id=atstbx_flattr class="at-share-tbx-element addthis-smartlayers addthis-animated at4-show"><div class=at-share-btn-elements><a role=button class="at-icon-wrapper at-share-btn flattr" href="https://flattr.com/submit/auto?fid=vo26re&url=http%3A%2F%2Fveewee.github.io%2Fblog%2Fauthenticating-with-x509-client-certificates" target=_blank><span class=at4-visually-hidden>Flattr this</span><span class=at-icon-wrapper style=""><svg xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink version=1.1 id=Capa_1 x=0px y=0px width=22px height=22px viewbox="0 0 533.333 533.333" style="enable-background:new 0 0 533.333 533.333" xml:space=preserve><g><path d="M191.438,0C64.689,0,0,73.001,0,209.3l0,0v95.211v190.745L124.161,370.97V225.711c0-56.466,14.964-92.399,65.166-100.466   l0,0c17.538-3.429,54.037-2.228,77.243-2.228l0,0v86.248c0,0.786,0.107,2.191,0.31,2.909l0,0c0.974,3.492,4.13,6.05,7.872,6.058   l0,0c2.116,0.004,4.098-1.096,6.143-3.109l0,0L496.06,0.033L351.627,0H191.438z M409.171,162.368v145.255   c0,56.466-14.967,92.403-65.164,100.466l0,0c-17.537,3.429-54.04,2.229-77.246,2.229l0,0V324.07c0-0.781-0.107-2.191-0.31-2.907   l0,0c-0.971-3.496-4.126-6.055-7.871-6.058l0,0c-2.117-0.004-4.097,1.1-6.141,3.107l0,0L37.271,533.299l144.431,0.034h160.191   c126.747,0,191.44-73.004,191.44-209.298l0,0V228.82V38.083L409.171,162.368z" fill=#FFFFFF></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg></span><span class=at-label>Flattr</span></a></div></div></div><a name=comments></a><div id=disqus_thread></div><script type=text/javascript>var disqus_identifier = '/blog/authenticating-with-x509-client-certificates';
        var disqus_title = 'Authenticating with X.509 client certificates';
        var disqus_url = 'http://veewee.github.io/blog/authenticating-with-x509-client-certificates';

        // trigger disqus-comments.js
        var embed_disqus_comments = true;</script></div></div><div class="col-xs-12 col-sm-4 col-md-3 right-pane"><h1>whois <small>VeeWee</small></h1><div><img src=/images/9064.picture.png class="img-thumbnail img-responsive selfie" alt=Selfie></div><div><h2>Hi there!</h2><p>Glad you made it to my blog. Please feel free to take a look around. You will find some interesting stuff, mostly about web development and PHP.</p><p>Still can't get enough of me? Quick! Take a look at my <a href=//twitter.com/toonverwerft>Twitter</a> and <a href="//github.com/veewee/">Github</a> account.</p></div><div class=list-group><a class=list-group-item href=//github.com/veewee/veewee.github.io/issues/new><span class="glyphicon glyphicon-pencil"></span> Contact Me</a> <a class=list-group-item href=/atom.xml><span class="glyphicon glyphicon-pushpin"></span> Subscribe to RSS</a></div></div></div></div></div><script src=/js/b1a7.vendor.js></script><script src=/js/e51f.blog.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57d8dc41723aa026"></script></body></html>