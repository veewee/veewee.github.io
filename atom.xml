<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Toon Verwerft - VeeWee</title>
    <link href="http://veewee.github.io/atom.xml" rel="self"/>
    <link href="http://veewee.github.io/"/>
    <updated>2014-01-23T08:38:51+01:00</updated>
    <id>http://veewee.github.io</id>
    <author>
        <name>Toon Verwerft</name>
        <uri>http://veewee.github.io/</uri>
        <email>toonverwerft@gmail.com</email>
    </author>
    
    <entry>
        <title>Validating your PHP code on the fly</title>
        <link href="http://veewee.github.io/blog/validating-your-php-code-on-the-fly"/>
        <updated>2014-01-21T00:00:00+01:00</updated>
        <id>http://veewee.github.io/blog/validating-your-php-code-on-the-fly</id>
        <content type="html">&lt;p&gt;
    It's amazing how much time you can loose while running PHP tests.
    First you alter your code or test. Next you start your test and wait for it to finish.
    Finally you find out you messed up and start the process all over again.
    In this article I am going to show you how to automate PHP testing,
    so you can focus on adding business value to your application.
&lt;/p&gt;

&lt;p&gt;
    For this article I created a simple
    &lt;a href=&quot;http://framework.zend.com/&quot; target=&quot;_blank&quot;&gt;Zend Framework 2&lt;/a&gt;
    application with
    &lt;a href=&quot;http://www.phpspec.net/&quot; target=&quot;_blank&quot;&gt;Phpspec&lt;/a&gt; tests.
    Even though this article focuses on these 2 packages,
    it is possible to create this kind of automation for every possible package.
&lt;/p&gt;

&lt;h2&gt;Application structure&lt;/h2&gt;

&lt;p&gt;
    First, let's take a look at the directory structure.
    In the representation below, you can see a default ZF2 skeleton.
    The root folder contains the directories config, module, public and vendor.
    The `config` folder provides the application configuration.
    In the `module` folder you can see 2 modules that should be tested: Export and Import.
    Next you can find the public directory which will bootstrap the application.
    And finally there is the vendor folder that will be filled with dependencies by
    &lt;a href=&quot;https://getcomposer.org/&quot; target=&quot;_blank&quot;&gt;Composer&lt;/a&gt;.
&lt;/p&gt;

&lt;pre&gt;
.
|-- config
|   |-- application.config.php
|-- module
|   |-- Export
|   |   |-- config
|   |   |-- spec
|   |   |-- src
|   |   |  `-- Export
|   |   |       |-- Service
|   |   |       `-- Module.php
|   |   |-- view
|   |   `-- Module.php
|   `-- Import
|       |-- config
|       |-- spec
|       |-- src
|       |  `-- Import
|       |       |-- Service
|       |       `-- Module.php
|       |-- view
|       `-- Module.php
|-- public
|-- vendor
&lt;/pre&gt;

&lt;h2&gt;Configuring composer&lt;/h2&gt;

&lt;p&gt;
    Because nobody wants to download all the dependencies manually, we will be using composer to get the required packages.
    We also want to configure composer to automatically load our custom modules: Export and Import.
    This way, no additional autoloading is required and Phpspec will be able to find all classes by itself.
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;composer.json&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
{
    &quot;name&quot;: &quot;veewee/validating-on-the-fly&quot;,
    &quot;require&quot;: {
        &quot;zendframework/zendframework&quot;: &quot;2.*&quot;,
    },
    &quot;require-dev&quot;: {
        &quot;phpspec/phpspec&quot;: &quot;dev-master&quot;,
        &quot;fabpot/PHP-CS-Fixer&quot;: &quot;*&quot;,
    },
    &quot;minimum-stability&quot;: &quot;dev&quot;,
    &quot;prefer-stable&quot;: true,
    &quot;autoload&quot;: {
        &quot;psr-0&quot;: {
          &quot;Export&quot;: &quot;module/Export/src/&quot;,
          &quot;Import&quot;: &quot;module/Import/src/&quot;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;
    As you can see, composer will download Zend Framework 2 to the vendor directory.
    When you add the option `--dev` during the installation, Phpspec and PHP-CS-Fixer will also be downloaded.
    The last part of this configuration file will provide autoloading for the custom Export and Import module.
    To download and install all the dependencies, one command is being used:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ composer install --dev --prefer-dist
&lt;/pre&gt;

&lt;h2&gt;Configuring phpspec&lt;/h2&gt;

&lt;p&gt;
    As you can see in the directory overview, there is already a spec folder available.
    The Phpspec tests will be placed in this directory.
    This way, every module has it's own scope and can be tested separately.
&lt;/p&gt;

&lt;p&gt;
    Now the tricky part: let's tell Phpspec where to find the custom source and spec files.
    Because we need to test multiple modules on multiple locations, we need to add multiple test suites to Phpspec.
    This is done by creating a phpspec.yml file in the root folder of the application.
    A test suite describes where the source and spec files of a custom namespace are located.
    Let's take a look at the configuration file for our application:
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;phpspec.yml&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-yml&quot;&gt;
formatter.name: dot
suites:
  Export:
    namespace: Export
    src_path: 'module/Export/src/'
    spec_path: 'module/Export/'

  Import:
    namespace: Import
    src_path: 'module/Import/src/'
    spec_path: 'module/Import/'
&lt;/pre&gt;

&lt;p&gt;
    One of the downsides of Phpspec is that, at the moment, you can not run suites based on suite name.
    To test this configuration, you can run following commands:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ ./vendor/bin/phpspec run module/Export/src
~$ ./vendor/bin/phpspec run module/Import/src
&lt;/pre&gt;

&lt;h2&gt;Configuring php-cs-fixer&lt;/h2&gt;

&lt;p&gt;
    Everybody wants clean, readable and maintainable code.
    That is why the code of the modules should be validated against the desired PHP standards.
    In this case, we want to check our classes against the
    &lt;a href=&quot;https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md&quot; target=&quot;_blank&quot;&gt;PSR2&lt;/a&gt;
    standard.
    Per module, you should add a file called .php_cs in the root directory of the module.
    In this file you can tell the
    &lt;a href=&quot;https://github.com/fabpot/PHP-CS-Fixer&quot; target=&quot;_blank&quot;&gt;Php-CS-Fixer&lt;/a&gt;
    which paths to check and add some default configuration settings.
&lt;/p&gt;

&lt;p&gt;
    &lt;strong&gt;.php_cs&lt;/strong&gt;
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-php&quot;&gt;
&amp;lt;?php
$finder = Symfony\CS\Finder\DefaultFinder::create()
    -&gt;exclude('language')
    -&gt;exclude('view')
    -&gt;exclude('config')
    -&gt;in(__DIR__ . '/src')
    -&gt;in(__DIR__ . '/spec');

$config = Symfony\CS\Config\Config::create();
$config-&gt;fixers(Symfony\CS\FixerInterface::PSR2_LEVEL);
$config-&gt;finder($finder);
return $config;
&lt;/pre&gt;

&lt;p&gt;
    To test this configuration, you can run following commands:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ ./vendor/bin/php-cs-fixer fix module/Export --dry-run
~$ ./vendor/bin/php-cs-fixer fix module/Import --dry-run
&lt;/pre&gt;

&lt;h2&gt;Automate the testing process&lt;/h2&gt;

&lt;p&gt;
    Before the automation, every time you change a file in your module,
    you need to run Phpspec and occasionally the Php-CS-Fixer to validate your code.
    Because you have to define which module to check every time you run the command,
    you will spend some time searching for the right command in your console.
    A better way is to automate this process, so that a file change will trigger the command to test your code.
    This will save you some time and will give you an indication of when and where you messed up.
    What was that tool again to automate tasks? Exactly:
    &lt;a href=&quot;http://gruntjs.com/&quot; target=&quot;_blank&quot;&gt;Grunt&lt;/a&gt;!
&lt;/p&gt;

&lt;p&gt;
    There are some grunt plugins that can be used to automate PHP validation.
    In this article we are using
    &lt;a href=&quot;https://npmjs.org/package/grunt-phpspec&quot; target=&quot;_blank&quot;&gt;Phpspec&lt;/a&gt;,
    but there are also plugins for other testing libraries like
    &lt;a href=&quot;https://npmjs.org/package/grunt-phpunit&quot; target=&quot;_blank&quot;&gt;Phpunit&lt;/a&gt;
    and
    &lt;a href=&quot;https://npmjs.org/package/grunt-parallel-behat&quot; target=&quot;_blank&quot;&gt;Behat&lt;/a&gt;.
    In the next part, I will tell you how to test your code on syntax errors,
    coding standard errors and bad functionality.
&lt;/p&gt;

&lt;h3&gt;Grunt-Phpspec&lt;/h3&gt;

&lt;p&gt;
    For validating bad functionality we use
    &lt;a href=&quot;https://npmjs.org/package/grunt-phpspec&quot;&gt;grunt-phpspec&lt;/a&gt;.
    This tool will run Phpspec on our custom modules.
    For every PHP module we need to check, an entry in the configuration is required.
    Here is the sample configuration for the current project:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
phpspec: {
  options: {
    prefix: './vendor/bin/'
  },
  export: {
    specs: 'module/Export/src'
  },
  import: {
    specs: 'module/Import/src'
  }
}
&lt;/pre&gt;

&lt;p&gt;
    To run spec tests, you can use following commands:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ grunt phpspec
~$ grunt phpspec:export
~$ grunt phpspec:import
&lt;/pre&gt;

&lt;h3&gt;Grunt-php-cs-fixer&lt;/h3&gt;

&lt;p&gt;
    The tool for validating PHP coding standards is
    &lt;a href=&quot;https://npmjs.org/package/grunt-php-cs-fixer&quot; target=&quot;_blank&quot;&gt;grunt-php-cs-fixer&lt;/a&gt;.
    As the name suggests: it does not only check for issues, it also fixes them.
    Therefore it must be possible to validate and fix errors with Grunt.
    This can be done by adding the parameter `--fixcs`.
    Here is the sample configuration for the current project:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
// Place this parameter before grunt.initConfig() method:
var fixCs = grunt.option('fixcs') || false;

// Place this configuration in grunt.initConfig() method:
phpcsfixer: {
  options: {
    bin: 'vendor/bin/php-cs-fixer',
    verbose: true,
    dryRun: !fixCs,
    ignoreExitCode: fixCs,
    level: 'psr2',
    standard: 'Zend'
  },
  export: {
    dir: 'module/Export'
  },
  import: {
    dir: 'module/Import'
  }
}
&lt;/pre&gt;

&lt;p&gt;
    To run the cs fixer, you can use following commands:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
// Validating:
~$ grunt phpcsfixer
~$ grunt phpcsfixer:export
~$ grunt phpcsfixer:import

// Fixing
~$ grunt phpcsfixer --fixcs
~$ grunt phpcsfixer:export --fixcs
~$ grunt phpcsfixer:import --fixcs
&lt;/pre&gt;

&lt;h3&gt;Grunt-Phplint&lt;/h3&gt;

&lt;p&gt;
    To validate PHP files for syntax errors you can use the commnd `php -l`.
    For automation, there is also a Grunt plugin available named
    &lt;a href=&quot;https://npmjs.org/package/grunt-phplint&quot; target=&quot;_blank&quot;&gt;grunt-phplint&lt;/a&gt;.
    This tool is added to the test suite
    to make sure the CS-fixer and spec tests only run when there is no syntax error.
    Here is the sample configuration for the current project:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
phplint: {
  export: ['module/Export/**/*.php'],
  import: ['module/Import/**/*.php']
}
&lt;/pre&gt;

&lt;p&gt;
    To run PHP lint, you can use following commands:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ grunt phplint
~$ grunt phplint:export
~$ grunt phplint:import
&lt;/pre&gt;

&lt;h3&gt;Grunt-watch&lt;/h3&gt;

&lt;p&gt;
    Now that we configured all tasks to validate the PHP code,
    we want the tests to run every time we change a class or spec test in our module.
    This is where
    &lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-watch&quot; target=&quot;_blank&quot;&gt;grunt-contrib-watch&lt;/a&gt;
    comes in to play.
    This task will listen for file changes and will configured tasks for these files.
    When one of the tasks fail, the other tasks will not run.
    This is why I decided to run the tests in the order: lint, csfixer, phpspec.
    Here is the sample configuration for the current project:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
watch: {
  export: {
    files: ['module/Export/**/*.php'],
    tasks: ['phplint:export', 'phpcsfixer:export', 'phpspec:export']
  },
  import: {
    files: ['module/Import/**/*.php'],
    tasks: ['phplint:import', 'phpcsfixer:import', 'phpspec:import']
  }
},
&lt;/pre&gt;

&lt;p&gt;
    To start the watcher and automate the tests, you only have to use one command:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ grunt watch
&lt;/pre&gt;

&lt;h3&gt;Run all tests in one&lt;/h3&gt;

&lt;p&gt;
    For Continious Integration it would be nice if all tests could be run in one command.
    Well off course this is possible! It is just one line of configuration:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
grunt.registerTask('test', ['phplint', 'phpcsfixer', 'phpspec']);
&lt;/pre&gt;

&lt;p&gt;
    To start the complete test, you can use following command:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ grunt test
&lt;/pre&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;
    As you can see there are some tools to configure.
    Once the tools are configured, this set-up will save you some valuable time while testing your code.
    I highly recommend you to use a similar set-up because it is very easy to use yet very powerful.
    You won't regret!
&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>Grand Opening!</title>
        <link href="http://veewee.github.io/blog/grand-opening"/>
        <updated>2014-01-14T00:00:00+01:00</updated>
        <id>http://veewee.github.io/blog/grand-opening</id>
        <content type="html">&lt;p&gt;
    With a new year, come some new resolutions. I was already thinking of creating a blog for quite some time,
    but the new year forced me to finally get this site up and running. So why did I start this blog?
    Not to tell you who I am, but to inform you about some cool stuff I encounter during the development of web applications.
&lt;/p&gt;

&lt;p&gt;
    Just another blog you think? Ok that's true ... Except ...&lt;br /&gt;
    Last year I found myself digging in the latest subjects of Web Development.
    Some of these subjects are poor documented and are not handled by many blog articles.
    My goal is to help you fix the issues that I encountered while using open-source modules.
    That, and off course to tell you more about some cool tools / projects I found.
&lt;/p&gt;

&lt;p&gt;
    Let's not let my first blog article go to waste and add some technical information about this blog.
&lt;/p&gt;

&lt;h2&gt;Choose the right platform&lt;/h2&gt;

&lt;p&gt;
    The first problem while creating this blog, was deciding which platform to use.
    At first there were the obvious platforms like Wordpress or some well-known hosted services like Blogger.
    Because I rather didn't want to use these platforms, I went on a blog-platform-quest.
    After a while I bumped into &lt;a href=&quot;http://jekyllrb.com/&quot; target=&quot;_blank&quot;&gt;Jekyll&lt;/a&gt;.
    This Ruby based static site generator is easy to use and is perfect for building something as simple as this blog.
    Extra bonus: you can deploy to github pages instead of wasting your own web space!
&lt;/p&gt;

&lt;p&gt;
    Off course, there were dozens of people who already worked with Jekyll before me.
    That is Why I searched for some good articles about building a blog for GitHub pages.
    One of the results I found was the
    &lt;a href=&quot;http://erjjones.github.io/blog/How-I-built-my-blog-in-one-day/&quot; target=&quot;_blank&quot;&gt;&amp;quot;How to build a blog in one day&amp;quot;&lt;/a&gt;
    article by
    &lt;a href=&quot;http://erjjones.github.io/&quot; target=&quot;_blank&quot;&gt;Eric Jones&lt;/a&gt;.
    This was a good place to start, but after some boring repeated tasks like the configuration of tools,
    I found a great tool to build this site:
&lt;/p&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;p&gt;
    By installing the
    &lt;a href=&quot;https://github.com/robwierzbowski/generator-jekyllrb&quot; target=&quot;_blank&quot;&gt;jekyllrb&lt;/a&gt;
    generator for
    &lt;a href=&quot;http://yeoman.io/&quot; target=&quot;_blank&quot;&gt;yeoman&lt;/a&gt;, all the work was done for me. Following items were configured:
    &lt;ul&gt;
        &lt;li&gt;Files structure&lt;/li&gt;
        &lt;li&gt;Grunt configuration&lt;/li&gt;
        &lt;li&gt;Compass&lt;/li&gt;
        &lt;li&gt;File watcher - which is much better than the default Jekyll watcher!&lt;/li&gt;
        &lt;li&gt;LiveReload&lt;/li&gt;
        &lt;li&gt;Jekyll configuration options&lt;/li&gt;
        &lt;li&gt;Bower: Twitter Bootstrap / jQuery / ...&lt;/li&gt;
    &lt;/ul&gt;

    All that it took to let me focus on the lay-out and content, were 2 commands:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ npm install -g generator-jekyllrb
~$ yo jekyllrb
&lt;/pre&gt;

&lt;h2&gt;Development&lt;/h2&gt;

&lt;p&gt;
    The real power of this generator, is the integration with &lt;a href=&quot;gruntjs.com&quot;&gt;grunt&lt;/a&gt;.
    Several handy tasks are pre-configured for you to use. For example:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ grunt serve
&lt;/pre&gt;

&lt;p&gt;
    This command will launch the Jekyll server and will rebuild the static website on file changes.
    When the static site is build, the livereload task will refresh your browser, so you can validate your changes right away.
    Also your compass files will be automatically converted to usable CSS files.
&lt;/p&gt;

&lt;h2&gt;Publishing&lt;/h2&gt;

&lt;p&gt;
    So, you finished your blog and want to place it on github.io?
    I forgot to tell you there is one little problem left.
    Github.io uses the root of the master branch to find your index.html file.
    Because yeoman creates your site in a subfolder called &quot;app&quot;, github.io will not find your files.
    That is why we need to separate our development code from the final site.
    The distribution version will be placed on the 'master' branch and the main code will be placed on a separate branch named 'develop'.
    In GIT, this can be done by creating an &lt;a href=&quot;http://www.git-tower.com/files/applicationHelp/pgs/Refs_Branches_DetachedOrphaned.html&quot;&gt;'orphan'&lt;/a&gt; branch, in this case named 'develop'.
    When you finished your blog, the final site should be committed to 'master' and the source code should be committed to 'develop'.
    I hear you say: So much work to deploy my blog?
    Fortunately there is a grunt tool named &lt;a href=&quot;https://npmjs.org/package/grunt-gh-pages&quot;&gt;gh-pages&lt;/a&gt; which does the job.
    I used following configuration which will commit my 'dist' folder of the 'develop' branch to the 'master' branch in git.
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
'gh-pages': {
  options: {
    base: 'dist',
    branch: 'master',
    message: 'Auto-generated build',
  },
  src: '**/*'
}

grunt.registerTask('github-deploy', [
    'default',
    'gh-pages'
]);

&lt;/pre&gt;

&lt;p&gt;
    Now, when you want to publish your site, it's just one simple command:
&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
~$ grunt github-deploy
&lt;/pre&gt;

&lt;p&gt;
    This will first clean up all temporary files and validate your Jekyll site, javascript and compass files.
    When everything is good to go, it will build the static version of your website for distribution.
    The files in the distribution folder will be minimized and optimized for quick access.
    After all actions are done, the optimized version will be pushed to your master branch, using the gh-pages tool in grunt.
&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;
    With these easy to use, but incredibly powerful tools,
    I hope to focus myself on writing articles about some interesting topics.
    If you want to take a look at my configuration or want to re-use it for your own project,
    feel free to fork &lt;a href=&quot;http://github.com/veewee/veewee.github.io&quot;&gt;veewee.github.io&lt;/a&gt;
    from my &lt;a href=&quot;http://github.com/veewee/&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; account.
&lt;/p&gt;
</content>
    </entry>
    
</feed>